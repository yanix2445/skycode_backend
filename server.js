require("dotenv").config();
require("dotenv").config();

const express = require("express");
const cors = require("cors");
const { Pool } = require("pg");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcryptjs"); // üî• Utilisation de bcryptjs au lieu de bcrypt
const crypto = require("crypto");
const rateLimit = require("express-rate-limit");

// üõ°Ô∏è Limite `/refresh` √† 1 requ√™te toutes les 10 secondes par IP
const refreshLimiter = rateLimit({
    windowMs: 10 * 1000, // 10 secondes
    max: 1, // 1 requ√™te max par IP
    message: { error: "Trop de requ√™tes, r√©essaie plus tard." }
});
const SECRET_KEY = process.env.JWT_SECRET || "fallback_secret"; // üî• R√©cup√®re la cl√© depuis `.env`

console.log("üöÄ Tentative de connexion √† PostgreSQL...");

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    require: true,
    rejectUnauthorized: false,
  },
});

// V√©rifier la connexion √† PostgreSQL au d√©marrage
pool
  .connect()
  .then((client) => {
    console.log("‚úÖ Connexion √† PostgreSQL r√©ussie !");
    client.release();
  })
  .catch((err) => {
    console.error("‚ùå Erreur de connexion √† PostgreSQL :", err);
    process.exit(1); // Arr√™te l'application si la connexion √©choue
  });

const app = express();
app.use(cors());
app.use(express.json()); // üî• Active le support JSON

// ‚úÖ Route principale pour tester le serveur
app.get("/", async (req, res) => {
  console.log("‚úÖ Requ√™te re√ßue sur `/`");
  res.send("üöÄ API backend en ligne !");
});

// ‚úÖ V√©rifier la connexion √† la base de donn√©es
app.get("/db-test", async (req, res) => {
  try {
    console.log("üîÑ V√©rification de la connexion √† PostgreSQL...");
    const client = await pool.connect();
    const result = await client.query("SELECT NOW()");
    client.release();
    console.log("‚úÖ Connexion PostgreSQL OK :", result.rows[0]);
    res.json({ status: "‚úÖ Connexion r√©ussie", timestamp: result.rows[0] });
  } catch (err) {
    console.error("‚ùå Erreur de connexion :", err);
    res.status(500).json({ error: err.message });
  }
});




// ‚úÖ R√©cup√©rer tous les utilisateurs
app.get("/users", async (req, res) => {
  try {
    console.log("üîÑ R√©cup√©ration des utilisateurs...");
    const result = await pool.query("SELECT * FROM users");
    res.json(result.rows);
  } catch (err) {
    console.error("‚ùå Erreur lors de la r√©cup√©ration des utilisateurs :", err);
    res.status(500).json({ error: err.message });
  }
});

// ‚úÖ R√©cup√©ration des utilisateurs avec pagination et filtrage
app.get("/users", authenticateToken, isAdmin, async (req, res) => {
  try {
      let { role, page = 1, limit = 10 } = req.query; 

      page = parseInt(page, 10) || 1;  // Convertit en nombre entier
      limit = parseInt(limit, 10) || 10; // D√©finit un max par d√©faut

      const offset = (page - 1) * limit; // Calcule l‚Äôoffset

      console.log(`üîÑ R√©cup√©ration des utilisateurs (Page: ${page}, Limit: ${limit}, R√¥le: ${role || "tous"})`);

      // Construire la requ√™te SQL dynamique
      let query = "SELECT id, name, email, role FROM users";
      let queryParams = [];

      if (role) {
          query += " WHERE role = $1";
          queryParams.push(role);
      }

      query += ` ORDER BY id ASC LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`;
      queryParams.push(limit, offset);

      console.log("üîç Requ√™te SQL ex√©cut√©e :", query, queryParams);

      const result = await pool.query(query, queryParams);

      // Compter le nombre total d'utilisateurs pour la pagination
      let countQuery = "SELECT COUNT(*) FROM users";
      let countParams = [];

      if (role) {
          countQuery += " WHERE role = $1";
          countParams.push(role);
      }

      const totalCount = await pool.query(countQuery, countParams);
      const totalUsers = parseInt(totalCount.rows[0].count, 10);

      // Calcul du nombre total de pages
      const totalPages = Math.ceil(totalUsers / limit);

      res.json({
          totalUsers,
          totalPages,
          currentPage: page,
          perPage: limit,
          users: result.rows
      });

  } catch (err) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration des utilisateurs :", err);
      res.status(500).json({ error: err.message });
  }
});

// ‚úÖ Modifier un utilisateur
app.put("/users/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email } = req.body;
    console.log(`üîÑ Modification de l'utilisateur ${id}...`);

    const checkUser = await pool.query("SELECT * FROM users WHERE id = $1", [
      id,
    ]);
    if (checkUser.rows.length === 0) {
      return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    const result = await pool.query(
      "UPDATE users SET name = $1, email = $2 WHERE id = $3 RETURNING *",
      [name, email, id]
    );
    console.log("‚úÖ Utilisateur modifi√© :", result.rows[0]);
    res.json(result.rows[0]);
  } catch (err) {
    console.error("‚ùå Erreur lors de la modification :", err);
    res.status(500).json({ error: err.message });
  }
});

// ‚úÖ Supprimer un utilisateur
app.delete("/users/:id", async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`üîÑ Suppression de l'utilisateur ${id}...`);

    const checkUser = await pool.query("SELECT * FROM users WHERE id = $1", [
      id,
    ]);
    if (checkUser.rows.length === 0) {
      return res.status(404).json({ error: "Utilisateur non trouv√©" });
    }

    await pool.query("DELETE FROM users WHERE id = $1", [id]);
    console.log("‚úÖ Utilisateur supprim√© !");
    res.json({ message: "Utilisateur supprim√© avec succ√®s" });
  } catch (err) {
    console.error("‚ùå Erreur lors de la suppression :", err);
    res.status(500).json({ error: err.message });
  }
});

app.get("/admin/users", authenticateToken, isAdmin, async (req, res) => {
  try {
    const users = await pool.query("SELECT id, name, email, role FROM users");
    res.json(users.rows);
  } catch (err) {
    console.error("‚ùå Erreur :", err);
    res.status(500).json({ error: err.message });
  }
});

app.put("/update-profile", authenticateToken, async (req, res) => {
  try {
      const { name, email, password } = req.body;
      const userId = req.user.id; // R√©cup√©ration de l'ID du user connect√©

      console.log(`‚úèÔ∏è Mise √† jour du profil pour l'utilisateur ID: ${userId}`);

      // V√©rifier si l'utilisateur existe
      const user = await pool.query("SELECT * FROM users WHERE id = $1", [userId]);
      if (user.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      let hashedPassword = user.rows[0].password;
      if (password) {
          hashedPassword = await bcrypt.hash(password, 10);
      }

      // Mettre √† jour l'utilisateur
      const result = await pool.query(
          "UPDATE users SET name = $1, email = $2, password = $3 WHERE id = $4 RETURNING id, name, email",
          [name || user.rows[0].name, email || user.rows[0].email, hashedPassword, userId]
      );

      console.log(`‚úÖ Profil mis √† jour avec succ√®s pour ID: ${userId}`);

      res.json({ message: "Profil mis √† jour avec succ√®s", user: result.rows[0] });
  } catch (err) {
      console.error("‚ùå Erreur lors de la mise √† jour du profil :", err);
      res.status(500).json({ error: err.message });
  }
});

app.delete("/delete-account", authenticateToken, async (req, res) => {
  try {
      const userId = req.user.id;

      console.log(`üóëÔ∏è Suppression du compte ID: ${userId}`);

      // V√©rifier si l'utilisateur existe
      const user = await pool.query("SELECT * FROM users WHERE id = $1", [userId]);
      if (user.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      // Supprimer l'utilisateur en base
      await pool.query("DELETE FROM users WHERE id = $1", [userId]);

      console.log(`‚úÖ Compte supprim√© avec succ√®s ID: ${userId}`);

      res.json({ message: "Compte supprim√© avec succ√®s" });
  } catch (err) {
      console.error("‚ùå Erreur lors de la suppression du compte :", err);
      res.status(500).json({ error: err.message });
  }
});

app.get("/users/:id", authenticateToken, isAdmin, async (req, res) => {
  try {
      const { id } = req.params;

      console.log(`üîç Recherche de l'utilisateur ID: ${id}`);

      const user = await pool.query("SELECT id, name, email, role FROM users WHERE id = $1", [id]);

      if (user.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      res.json(user.rows[0]);
  } catch (err) {
      console.error("‚ùå Erreur lors de la r√©cup√©ration de l'utilisateur :", err);
      res.status(500).json({ error: err.message });
  }
});

// üîÑ Modification d'un utilisateur (admin uniquement)
app.put("/users/:id", authenticateToken, isAdmin, async (req, res) => {
  try {
      const { id } = req.params;
      const { name, email, role } = req.body;

      console.log(`‚úèÔ∏è Mise √† jour de l'utilisateur ID: ${id}`);

      // V√©rifier si l'utilisateur existe
      const user = await pool.query("SELECT * FROM users WHERE id = $1", [id]);
      if (user.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      // Mise √† jour des informations
      const result = await pool.query(
          "UPDATE users SET name = $1, email = $2, role = $3 WHERE id = $4 RETURNING id, name, email, role",
          [name || user.rows[0].name, email || user.rows[0].email, role || user.rows[0].role, id]
      );

      console.log(`‚úÖ Utilisateur ID: ${id} mis √† jour avec succ√®s`);

      res.json({ message: "Utilisateur mis √† jour avec succ√®s", user: result.rows[0] });
  } catch (err) {
      console.error("‚ùå Erreur lors de la mise √† jour de l'utilisateur :", err);
      res.status(500).json({ error: err.message });
  }
});

// üóëÔ∏è Suppression d'un utilisateur (admin uniquement)
app.delete("/users/:id", authenticateToken, isAdmin, async (req, res) => {
  try {
      const { id } = req.params;

      console.log(`üóëÔ∏è Suppression de l'utilisateur ID: ${id}`);

      const user = await pool.query("SELECT * FROM users WHERE id = $1", [id]);
      if (user.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      await pool.query("DELETE FROM users WHERE id = $1", [id]);

      console.log(`‚úÖ Utilisateur ID: ${id} supprim√© avec succ√®s`);

      res.json({ message: "Utilisateur supprim√© avec succ√®s" });
  } catch (err) {
      console.error("‚ùå Erreur lors de la suppression de l'utilisateur :", err);
      res.status(500).json({ error: err.message });
  }
});

// ‚úÖ Inscription d‚Äôun utilisateur
app.post("/signup", async (req, res) => {
  try {
    const { name, email, password, role } = req.body;
    console.log(`üîÑ Inscription de : ${name} - ${email}`);

    // V√©rifier si l'utilisateur existe d√©j√†
    const checkUser = await pool.query("SELECT * FROM users WHERE email = $1", [
      email,
    ]);
    if (checkUser.rows.length > 0) {
      return res.status(400).json({ error: "Email d√©j√† utilis√©" });
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 10);

    // üî• S√©curisation : Si aucun r√¥le n‚Äôest fourni, mettre `user` par d√©faut
    const userRole = role === "admin" ? "admin" : "user";

    // Ins√©rer le nouvel utilisateur dans la base
    const result = await pool.query(
      "INSERT INTO users (name, email, password, role) VALUES ($1, $2, $3, $4) RETURNING *",
      [name, email, hashedPassword, userRole]
    );

    res
      .status(201)
      .json({ message: "Compte cr√©√© avec succ√®s", user: result.rows[0] });
  } catch (err) {
    console.error("‚ùå Erreur lors de l'inscription :", err);
    res.status(500).json({ error: err.message });
  }
});

// ‚úÖ Connexion d‚Äôun utilisateur
app.post("/login", async (req, res) => {
  try {
      const { email, password } = req.body;
      console.log(`üîç Tentative de connexion pour : ${email}`);

      // V√©rifier si l'utilisateur existe
      const result = await pool.query("SELECT * FROM users WHERE email = $1", [email]);
      if (result.rows.length === 0) {
          console.warn(`‚ùå √âchec de connexion : Email ${email} introuvable`);
          return res.status(401).json({ error: "Email ou mot de passe incorrect" });
      }

      const user = result.rows[0];

      // V√©rifier le mot de passe
      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) {
          console.warn(`‚ùå √âchec de connexion : Mot de passe incorrect pour ${email}`);
          return res.status(401).json({ error: "Email ou mot de passe incorrect" });
      }

      console.log(`‚úÖ Connexion r√©ussie pour ${email} (ID: ${user.id}, R√¥le: ${user.role})`);

      // G√©n√©rer un JWT qui expire dans **7 jours**
      const accessToken = jwt.sign(
          { id: user.id, email: user.email, role: user.role },
          process.env.JWT_SECRET,
          { expiresIn: "7d" }
      );

      // G√©n√©rer un Refresh Token (90 jours)
      const refreshToken = crypto.randomBytes(64).toString("hex");

      // Stocker le Refresh Token en base
      await pool.query("UPDATE users SET refresh_token = $1 WHERE id = $2", [refreshToken, user.id]);

      console.log(`üîÑ Tokens g√©n√©r√©s : AccessToken (7j) & RefreshToken (90j) pour ${email}`);

      res.json({ message: "Connexion r√©ussie", accessToken, refreshToken });
  } catch (err) {
      console.error("‚ùå Erreur lors de la connexion :", err);
      res.status(500).json({ error: err.message });
  }
});

app.post("/refresh", refreshLimiter, async (req, res) => {
  try {
      const { refreshToken } = req.body;
      console.log(`üîÑ Tentative de rafra√Æchissement du token...`);

      if (!refreshToken) {
          console.warn("‚ùå Aucun Refresh Token fourni");
          return res.status(401).json({ error: "Refresh token requis" });
      }

      // V√©rifier si le Refresh Token existe en base
      const result = await pool.query("SELECT * FROM users WHERE refresh_token = $1", [refreshToken]);
      if (result.rows.length === 0) {
          console.warn(`‚ùå √âchec : Refresh Token invalide`);
          return res.status(403).json({ error: "Refresh token invalide" });
      }

      const user = result.rows[0];
      console.log(`‚úÖ Refresh Token valide pour ${user.email} (ID: ${user.id})`);

      // üîÑ G√©n√©rer un NOUVEAU JWT valide 7 jours
      const newAccessToken = jwt.sign(
          { id: user.id, email: user.email, role: user.role },
          process.env.JWT_SECRET,
          { expiresIn: "7d" }
      );

      // üîÑ G√©n√©rer un NOUVEAU Refresh Token
      const newRefreshToken = crypto.randomBytes(64).toString("hex");

      // üî• Stocker le NOUVEAU Refresh Token en base et supprimer l‚Äôancien
      await pool.query("UPDATE users SET refresh_token = $1 WHERE id = $2", [newRefreshToken, user.id]);

      console.log(`üîÑ Nouveau AccessToken + RefreshToken g√©n√©r√©s pour ${user.email}`);

      res.json({ accessToken: newAccessToken, refreshToken: newRefreshToken });
  } catch (err) {
      console.error("‚ùå Erreur lors du rafra√Æchissement du token :", err);
      res.status(500).json({ error: err.message });
  }
});

// ‚úÖ Route prot√©g√©e pour r√©cup√©rer le profil de l‚Äôutilisateur
app.get("/profile", authenticateToken, async (req, res) => {
  try {
    console.log(`üîÑ Profil demand√© pour l'utilisateur ID: ${req.user.id}`);

    const result = await pool.query(
      "SELECT id, name, email FROM users WHERE id = $1",
      [req.user.id]
    );
    res.json(result.rows[0]);
  } catch (err) {
    console.error("‚ùå Erreur lors de la r√©cup√©ration du profil :", err);
    res.status(500).json({ error: err.message });
  }
});

app.post("/logout", async (req, res) => {
  try {
      const { refreshToken } = req.body;
      console.log(`üö™ Tentative de d√©connexion...`);

      if (!refreshToken) {
          console.warn("‚ùå √âchec : Aucun Refresh Token fourni");
          return res.status(401).json({ error: "Refresh token requis" });
      }

      // Supprimer le Refresh Token en base
      const result = await pool.query("UPDATE users SET refresh_token = NULL WHERE refresh_token = $1 RETURNING email", [refreshToken]);

      if (result.rows.length === 0) {
          console.warn("‚ùå √âchec : Refresh Token introuvable en base");
          return res.status(403).json({ error: "Refresh token invalide" });
      }

      console.log(`‚úÖ D√©connexion r√©ussie pour ${result.rows[0].email}`);
      res.json({ message: "D√©connexion r√©ussie" });
  } catch (err) {
      console.error("‚ùå Erreur lors de la d√©connexion :", err);
      res.status(500).json({ error: err.message });
  }
});

app.post("/change-password", async (req, res) => {
  try {
      const { email, oldPassword, newPassword } = req.body;
      console.log(`üîê Changement de mot de passe pour ${email}`);

      // V√©rifier si l'utilisateur existe
      const result = await pool.query("SELECT * FROM users WHERE email = $1", [email]);
      if (result.rows.length === 0) {
          return res.status(404).json({ error: "Utilisateur introuvable" });
      }

      const user = result.rows[0];

      // V√©rifier l'ancien mot de passe
      const isMatch = await bcrypt.compare(oldPassword, user.password);
      if (!isMatch) {
          return res.status(401).json({ error: "Ancien mot de passe incorrect" });
      }

      // Hacher le nouveau mot de passe
      const hashedPassword = await bcrypt.hash(newPassword, 10);

      // üî• Mettre √† jour le mot de passe en base
      await pool.query("UPDATE users SET password = $1, refresh_token = NULL WHERE email = $2", [hashedPassword, email]);

      console.log(`‚úÖ Mot de passe chang√© avec succ√®s pour ${email} (Toutes les sessions ont √©t√© invalid√©es)`);

      res.json({ message: "Mot de passe chang√© avec succ√®s. Reconnectez-vous." });
  } catch (err) {
      console.error("‚ùå Erreur lors du changement de mot de passe :", err);
      res.status(500).json({ error: err.message });
  }
});


// ‚úÖ Middleware pour v√©rifier le token JWT
function authenticateToken(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1]; // üî• R√©cup√®re le token envoy√© par le client
  if (!token) {
    return res.status(401).json({ error: "Acc√®s refus√©, token manquant" });
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY); // üî• V√©rifie que le token est valide
    req.user = decoded; // üî• Ajoute les infos du user (id, email) dans `req`
    next(); // üî• Passe √† la prochaine √©tape
  } catch (err) {
    res.status(401).json({ error: "Token invalide" });
  }
}
// ‚úÖ Middleware pour v√©rifier le token JWT
function authenticateToken(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1]; // üî• R√©cup√®re le token envoy√© par le client
  if (!token) {
    return res.status(401).json({ error: "Acc√®s refus√©, token manquant" });
  }

  try {
    const decoded = jwt.verify(token, SECRET_KEY); // üî• V√©rifie que le token est valide
    req.user = decoded; // üî• Ajoute les infos du user (id, email) dans `req`
    next(); // üî• Passe √† la prochaine √©tape
  } catch (err) {
    res.status(401).json({ error: "Token invalide" });
  }
}

function isAdmin(req, res, next) {
  console.log("Role de l'utilisateur:", req.user.role); // üî• Debugging

  if (req.user.role !== "admin") {
    return res.status(403).json({ error: "Acc√®s interdit, admin requis" });
  }
  next();
}

// ‚úÖ Lancer le serveur
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`‚úÖ Serveur en cours d'ex√©cution sur le port ${PORT}`);
});
